// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "indexing_suite/map.hpp"

#include "pde_headers.hpp"

namespace bp = boost::python;

struct AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper : AbstractLinearEllipticPde< 3, 3 >, bp::wrapper< AbstractLinearEllipticPde< 3, 3 > > {

    AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : AbstractLinearEllipticPde<3, 3>( )
      , bp::wrapper< AbstractLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ){
        bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" );
        return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual double ComputeConstantInUSourceTermAtNode( ::Node< 3 > const & rNode ) {
        if( bp::override func_ComputeConstantInUSourceTermAtNode = this->get_override( "ComputeConstantInUSourceTermAtNode" ) )
            return func_ComputeConstantInUSourceTermAtNode( boost::ref(rNode) );
        else{
            return this->AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode( boost::ref(rNode) );
        }
    }
    
    double default_ComputeConstantInUSourceTermAtNode( ::Node< 3 > const & rNode ) {
        return AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode( boost::ref(rNode) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX ){
        bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" );
        return func_ComputeDiffusionTerm( boost::ref(rX) );
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual double ComputeLinearInUCoeffInSourceTermAtNode( ::Node< 3 > const & rNode ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTermAtNode = this->get_override( "ComputeLinearInUCoeffInSourceTermAtNode" ) )
            return func_ComputeLinearInUCoeffInSourceTermAtNode( boost::ref(rNode) );
        else{
            return this->AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode( boost::ref(rNode) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTermAtNode( ::Node< 3 > const & rNode ) {
        return AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode( boost::ref(rNode) );
    }

};

struct AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper : AbstractRegularGridDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 3 > > {

    AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractRegularGridDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< double > GetPointSolution(  ) {
        if( bp::override func_GetPointSolution = this->get_override( "GetPointSolution" ) )
            return func_GetPointSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution(  );
        }
    }
    
    ::std::vector< double > default_GetPointSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution( );
    }

    virtual ::std::vector< double > GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_GetSolutionAtGridPoints = this->get_override( "GetSolutionAtGridPoints" ) )
            return func_GetSolutionAtGridPoints( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
    }

    virtual ::std::vector< double > GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        if( bp::override func_GetSolutionAtPoints = this->get_override( "GetSolutionAtPoints" ) )
            return func_GetSolutionAtPoints( samplePoints );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > data ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( data );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > data ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct DiscreteSource_less__3__greater__wrapper : DiscreteSource< 3 >, bp::wrapper< DiscreteSource< 3 > > {

    DiscreteSource_less__3__greater__wrapper(DiscreteSource<3> const & arg )
    : DiscreteSource<3>( arg )
      , bp::wrapper< DiscreteSource< 3 > >(){
        // copy constructor
        
    }

    DiscreteSource_less__3__greater__wrapper( )
    : DiscreteSource<3>( )
      , bp::wrapper< DiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< double > GetCellRegularGridValues(  ) {
        if( bp::override func_GetCellRegularGridValues = this->get_override( "GetCellRegularGridValues" ) )
            return func_GetCellRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetCellRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetCellRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetCellRegularGridValues( );
    }

    virtual ::std::vector< double > GetPointRegularGridValues(  ) {
        if( bp::override func_GetPointRegularGridValues = this->get_override( "GetPointRegularGridValues" ) )
            return func_GetPointRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetPointRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetPointRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetPointRegularGridValues( );
    }

    virtual ::std::vector< double > GetSolutionDependentRegularGridValues(  ) {
        if( bp::override func_GetSolutionDependentRegularGridValues = this->get_override( "GetSolutionDependentRegularGridValues" ) )
            return func_GetSolutionDependentRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetSolutionDependentRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetSolutionDependentRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetSolutionDependentRegularGridValues( );
    }

    virtual ::std::vector< double > GetVesselRegularGridValues(  ) {
        if( bp::override func_GetVesselRegularGridValues = this->get_override( "GetVesselRegularGridValues" ) )
            return func_GetVesselRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetVesselRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetVesselRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetVesselRegularGridValues( );
    }

};

struct CellStateDependentDiscreteSource_less__3__greater__wrapper : CellStateDependentDiscreteSource< 3 >, bp::wrapper< CellStateDependentDiscreteSource< 3 > > {

    CellStateDependentDiscreteSource_less__3__greater__wrapper(CellStateDependentDiscreteSource<3> const & arg )
    : CellStateDependentDiscreteSource<3>( arg )
      , bp::wrapper< CellStateDependentDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    CellStateDependentDiscreteSource_less__3__greater__wrapper( )
    : CellStateDependentDiscreteSource<3>( )
      , bp::wrapper< CellStateDependentDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< double > GetCellRegularGridValues(  ) {
        if( bp::override func_GetCellRegularGridValues = this->get_override( "GetCellRegularGridValues" ) )
            return func_GetCellRegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetCellRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetCellRegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetCellRegularGridValues( );
    }

    virtual ::std::vector< double > GetPointRegularGridValues(  ) {
        if( bp::override func_GetPointRegularGridValues = this->get_override( "GetPointRegularGridValues" ) )
            return func_GetPointRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetPointRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetPointRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetPointRegularGridValues( );
    }

    virtual ::std::vector< double > GetSolutionDependentRegularGridValues(  ) {
        if( bp::override func_GetSolutionDependentRegularGridValues = this->get_override( "GetSolutionDependentRegularGridValues" ) )
            return func_GetSolutionDependentRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetSolutionDependentRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetSolutionDependentRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetSolutionDependentRegularGridValues( );
    }

    virtual ::std::vector< double > GetVesselRegularGridValues(  ) {
        if( bp::override func_GetVesselRegularGridValues = this->get_override( "GetVesselRegularGridValues" ) )
            return func_GetVesselRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetVesselRegularGridValues(  );
        }
    }
    
    ::std::vector< double > default_GetVesselRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetVesselRegularGridValues( );
    }

};

struct FiniteDifferenceSolver_less__3__greater__wrapper : FiniteDifferenceSolver< 3 >, bp::wrapper< FiniteDifferenceSolver< 3 > > {

    FiniteDifferenceSolver_less__3__greater__wrapper(FiniteDifferenceSolver<3> const & arg )
    : FiniteDifferenceSolver<3>( arg )
      , bp::wrapper< FiniteDifferenceSolver< 3 > >(){
        // copy constructor
        
    }

    FiniteDifferenceSolver_less__3__greater__wrapper( )
    : FiniteDifferenceSolver<3>( )
      , bp::wrapper< FiniteDifferenceSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        FiniteDifferenceSolver< 3 >::Setup( );
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteDifferenceSolver< 3 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteDifferenceSolver< 3 >::Update( );
    }

    virtual ::std::vector< double > GetPointSolution(  ) {
        if( bp::override func_GetPointSolution = this->get_override( "GetPointSolution" ) )
            return func_GetPointSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution(  );
        }
    }
    
    ::std::vector< double > default_GetPointSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution( );
    }

    virtual ::std::vector< double > GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_GetSolutionAtGridPoints = this->get_override( "GetSolutionAtGridPoints" ) )
            return func_GetSolutionAtGridPoints( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
    }

    virtual ::std::vector< double > GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        if( bp::override func_GetSolutionAtPoints = this->get_override( "GetSolutionAtPoints" ) )
            return func_GetSolutionAtPoints( samplePoints );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > data ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( data );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > data ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct FiniteElementSolver_less__3__greater__wrapper : FiniteElementSolver< 3 >, bp::wrapper< FiniteElementSolver< 3 > > {

    FiniteElementSolver_less__3__greater__wrapper(FiniteElementSolver<3> const & arg )
    : FiniteElementSolver<3>( arg )
      , bp::wrapper< FiniteElementSolver< 3 > >(){
        // copy constructor
        
    }

    FiniteElementSolver_less__3__greater__wrapper( )
    : FiniteElementSolver<3>( )
      , bp::wrapper< FiniteElementSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< double > GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_GetSolutionAtGridPoints = this->get_override( "GetSolutionAtGridPoints" ) )
            return func_GetSolutionAtGridPoints( pGrid );
        else{
            return this->FiniteElementSolver< 3 >::GetSolutionAtGridPoints( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        return FiniteElementSolver< 3 >::GetSolutionAtGridPoints( pGrid );
    }

    virtual ::std::vector< double > GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        if( bp::override func_GetSolutionAtPoints = this->get_override( "GetSolutionAtPoints" ) )
            return func_GetSolutionAtPoints( samplePoints );
        else{
            return this->FiniteElementSolver< 3 >::GetSolutionAtPoints( samplePoints );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        return FiniteElementSolver< 3 >::GetSolutionAtPoints( samplePoints );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->FiniteElementSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        FiniteElementSolver< 3 >::Setup( );
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteElementSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteElementSolver< 3 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteElementSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteElementSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->FiniteElementSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        FiniteElementSolver< 3 >::UpdateCellData( );
    }

};

struct FunctionMap_less__3__greater__wrapper : FunctionMap< 3 >, bp::wrapper< FunctionMap< 3 > > {

    FunctionMap_less__3__greater__wrapper(FunctionMap<3> const & arg )
    : FunctionMap<3>( arg )
      , bp::wrapper< FunctionMap< 3 > >(){
        // copy constructor
        
    }

    FunctionMap_less__3__greater__wrapper( )
    : FunctionMap<3>( )
      , bp::wrapper< FunctionMap< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FunctionMap< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FunctionMap< 3 >::Solve( );
    }

    virtual ::std::vector< double > GetPointSolution(  ) {
        if( bp::override func_GetPointSolution = this->get_override( "GetPointSolution" ) )
            return func_GetPointSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution(  );
        }
    }
    
    ::std::vector< double > default_GetPointSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution( );
    }

    virtual ::std::vector< double > GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_GetSolutionAtGridPoints = this->get_override( "GetSolutionAtGridPoints" ) )
            return func_GetSolutionAtGridPoints( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
    }

    virtual ::std::vector< double > GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        if( bp::override func_GetSolutionAtPoints = this->get_override( "GetSolutionAtPoints" ) )
            return func_GetSolutionAtPoints( samplePoints );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > data ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( data );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > data ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct GreensFunctionSolver_less__3__greater__wrapper : GreensFunctionSolver< 3 >, bp::wrapper< GreensFunctionSolver< 3 > > {

    GreensFunctionSolver_less__3__greater__wrapper(GreensFunctionSolver<3> const & arg )
    : GreensFunctionSolver<3>( arg )
      , bp::wrapper< GreensFunctionSolver< 3 > >(){
        // copy constructor
        
    }

    GreensFunctionSolver_less__3__greater__wrapper( )
    : GreensFunctionSolver<3>( )
      , bp::wrapper< GreensFunctionSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->GreensFunctionSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        GreensFunctionSolver< 3 >::Solve( );
    }

    virtual ::std::vector< double > GetPointSolution(  ) {
        if( bp::override func_GetPointSolution = this->get_override( "GetPointSolution" ) )
            return func_GetPointSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution(  );
        }
    }
    
    ::std::vector< double > default_GetPointSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution( );
    }

    virtual ::std::vector< double > GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_GetSolutionAtGridPoints = this->get_override( "GetSolutionAtGridPoints" ) )
            return func_GetSolutionAtGridPoints( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtGridPoints( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints( pGrid );
    }

    virtual ::std::vector< double > GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        if( bp::override func_GetSolutionAtPoints = this->get_override( "GetSolutionAtPoints" ) )
            return func_GetSolutionAtPoints( samplePoints );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
        }
    }
    
    ::std::vector< double > default_GetSolutionAtPoints( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > samplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints( samplePoints );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > data ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( data );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > data ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( data );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper : DiscreteContinuumLinearEllipticPde< 3, 3 >, bp::wrapper< DiscreteContinuumLinearEllipticPde< 3, 3 > > {

    DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper(DiscreteContinuumLinearEllipticPde<3, 3> const & arg )
    : DiscreteContinuumLinearEllipticPde<3, 3>( arg )
      , bp::wrapper< DiscreteContinuumLinearEllipticPde< 3, 3 > >(){
        // copy constructor
        
    }

    DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : DiscreteContinuumLinearEllipticPde<3, 3>( )
      , bp::wrapper< DiscreteContinuumLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        return DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual double ComputeConstantInUSourceTermAtNode( ::Node< 3 > const & rNode ) {
        if( bp::override func_ComputeConstantInUSourceTermAtNode = this->get_override( "ComputeConstantInUSourceTermAtNode" ) )
            return func_ComputeConstantInUSourceTermAtNode( boost::ref(rNode) );
        else{
            return this->AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode( boost::ref(rNode) );
        }
    }
    
    double default_ComputeConstantInUSourceTermAtNode( ::Node< 3 > const & rNode ) {
        return AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode( boost::ref(rNode) );
    }

    virtual double ComputeLinearInUCoeffInSourceTermAtNode( ::Node< 3 > const & rNode ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTermAtNode = this->get_override( "ComputeLinearInUCoeffInSourceTermAtNode" ) )
            return func_ComputeLinearInUCoeffInSourceTermAtNode( boost::ref(rNode) );
        else{
            return this->AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode( boost::ref(rNode) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTermAtNode( ::Node< 3 > const & rNode ) {
        return AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode( boost::ref(rNode) );
    }

};

struct DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper : DiscreteContinuumNonLinearEllipticPde< 3, 3 >, bp::wrapper< DiscreteContinuumNonLinearEllipticPde< 3, 3 > > {

    DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper(DiscreteContinuumNonLinearEllipticPde<3, 3> const & arg )
    : DiscreteContinuumNonLinearEllipticPde<3, 3>( arg )
      , bp::wrapper< DiscreteContinuumNonLinearEllipticPde< 3, 3 > >(){
        // copy constructor
        
    }

    DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : DiscreteContinuumNonLinearEllipticPde<3, 3>( )
      , bp::wrapper< DiscreteContinuumNonLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0, double u ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0), u );
        else{
            return this->DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0, double u ) {
        return DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" ) )
            return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
        else{
            return this->DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        return DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ) {
        if( bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" ) )
            return func_ComputeLinearSourceTerm( boost::ref(rX) );
        else{
            return this->DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearSourceTerm( boost::ref(rX) );
        }
    }
    
    double default_ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ) {
        return DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
        else{
            return this->DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ) {
        return DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        else{
            return this->DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        return DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::numeric::ublas::c_vector< double, 3 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< DiscreteSource< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(_chaste_project_Angiogenesis_pde){
    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
        bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
        vector_less__double__greater__exposer.def( bp::indexing::vector_suite< std::vector< double > >() );
    }

    { //::std::vector< boost::shared_ptr<DiscreteSource<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<DiscreteSource<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<DiscreteSource<3> > > >() );
    }

    { //::std::vector< boost::numeric::ublas::c_vector<double, 3> >
        typedef bp::class_< std::vector< boost::numeric::ublas::c_vector<double, 3> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::numeric::ublas::c_vector<double, 3> > >() );
    }

    { //::std::map< unsigned int, double >
        typedef bp::class_< std::map< unsigned int, double > > map_less__unsigned_int_comma__double__greater__exposer_t;
        map_less__unsigned_int_comma__double__greater__exposer_t map_less__unsigned_int_comma__double__greater__exposer = map_less__unsigned_int_comma__double__greater__exposer_t( "map_less__unsigned_int_comma__double__greater_" );
        bp::scope map_less__unsigned_int_comma__double__greater__scope( map_less__unsigned_int_comma__double__greater__exposer );
        map_less__unsigned_int_comma__double__greater__exposer.def( bp::indexing::map_suite< std::map< unsigned int, double > >() );
    }

    bp::class_< AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper, boost::noncopyable >( "AbstractLinearEllipticPde3_3", bp::init< >() )    
        .def( 
            "ComputeConstantInUSourceTerm"
            , bp::pure_virtual( (double ( ::AbstractLinearEllipticPde<3, 3>::* )( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ))(&::AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm) )
            , ( bp::arg("rX"), bp::arg("pElement") ) )    
        .def( 
            "ComputeConstantInUSourceTermAtNode"
            , (double ( ::AbstractLinearEllipticPde<3, 3>::* )( ::Node< 3 > const & ))(&::AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode)
            , (double ( AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper::* )( ::Node< 3 > const & ))(&AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTermAtNode)
            , ( bp::arg("rNode") ) )    
        .def( 
            "ComputeDiffusionTerm"
            , bp::pure_virtual( (::boost::numeric::ublas::c_matrix< double, 3, 3 > ( ::AbstractLinearEllipticPde<3, 3>::* )( ::ChastePoint< 3 > const & ))(&::AbstractLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm) )
            , ( bp::arg("rX") ) )    
        .def( 
            "ComputeLinearInUCoeffInSourceTerm"
            , bp::pure_virtual( (double ( ::AbstractLinearEllipticPde<3, 3>::* )( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ))(&::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm) )
            , ( bp::arg("rX"), bp::arg("pElement") ) )    
        .def( 
            "ComputeLinearInUCoeffInSourceTermAtNode"
            , (double ( ::AbstractLinearEllipticPde<3, 3>::* )( ::Node< 3 > const & ))(&::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode)
            , (double ( AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper::* )( ::Node< 3 > const & ))(&AbstractLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTermAtNode)
            , ( bp::arg("rNode") ) );

    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver3", bp::init< >() )    
        .def( 
            "GetGrid"
            , (::boost::shared_ptr< RegularGrid< 3, 3 > > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetGrid ) )    
        .def( 
            "GetPointSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetPointSolution) )    
        .def( 
            "GetSolutionAtGridPoints"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3, 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolutionAtGridPoints)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolutionAtPoints"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolutionAtPoints)
            , ( bp::arg("samplePoints") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetGrid"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3, 3 > > ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::SetGrid )
            , ( bp::arg("pRegularGrid") ) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Solve) ) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("data") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Write) );

    { //::BoundaryConditionSource
        typedef bp::class_< BoundaryConditionSource > BoundaryConditionSource_exposer_t;
        BoundaryConditionSource_exposer_t BoundaryConditionSource_exposer = BoundaryConditionSource_exposer_t( "BoundaryConditionSource" );
        bp::scope BoundaryConditionSource_scope( BoundaryConditionSource_exposer );
        bp::enum_< BoundaryConditionSource::Value>("Value")
            .value("LABEL_BASED", BoundaryConditionSource::LABEL_BASED)
            .value("PRESCRIBED", BoundaryConditionSource::PRESCRIBED)
            .export_values()
            ;
    }

    { //::BoundaryConditionType
        typedef bp::class_< BoundaryConditionType > BoundaryConditionType_exposer_t;
        BoundaryConditionType_exposer_t BoundaryConditionType_exposer = BoundaryConditionType_exposer_t( "BoundaryConditionType" );
        bp::scope BoundaryConditionType_scope( BoundaryConditionType_exposer );
        bp::enum_< BoundaryConditionType::Value>("Value")
            .value("POINT", BoundaryConditionType::POINT)
            .value("FACET", BoundaryConditionType::FACET)
            .value("OUTER", BoundaryConditionType::OUTER)
            .value("VESSEL_LINE", BoundaryConditionType::VESSEL_LINE)
            .value("VESSEL_VOLUME", BoundaryConditionType::VESSEL_VOLUME)
            .value("CELL", BoundaryConditionType::CELL)
            .value("IN_PART", BoundaryConditionType::IN_PART)
            .export_values()
            ;
    }

    { //::SourceStrength
        typedef bp::class_< SourceStrength > SourceStrength_exposer_t;
        SourceStrength_exposer_t SourceStrength_exposer = SourceStrength_exposer_t( "SourceStrength" );
        bp::scope SourceStrength_scope( SourceStrength_exposer );
        bp::enum_< SourceStrength::Value>("Value")
            .value("LABEL", SourceStrength::LABEL)
            .value("PRESCRIBED", SourceStrength::PRESCRIBED)
            .export_values()
            ;
    }

    { //::SourceType
        typedef bp::class_< SourceType > SourceType_exposer_t;
        SourceType_exposer_t SourceType_exposer = SourceType_exposer_t( "SourceType" );
        bp::scope SourceType_scope( SourceType_exposer );
        bp::enum_< SourceType::Value>("Value")
            .value("POINT", SourceType::POINT)
            .value("VESSEL", SourceType::VESSEL)
            .value("CELL", SourceType::CELL)
            .value("SOLUTION", SourceType::SOLUTION)
            .export_values()
            ;
    }

    { //::DiscreteSource< 3 >
        typedef bp::class_< DiscreteSource_less__3__greater__wrapper > DiscreteSource3_exposer_t;
        DiscreteSource3_exposer_t DiscreteSource3_exposer = DiscreteSource3_exposer_t( "DiscreteSource3", bp::init< >() );
        bp::scope DiscreteSource3_scope( DiscreteSource3_exposer );
        { //::DiscreteSource< 3 >::Create
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteSource< 3 > > ( *Create_function_type )(  );
            
            DiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteSource< 3 >::Create ) );
        
        }
        { //::DiscreteSource< 3 >::GetCellRegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetCellRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( DiscreteSource_less__3__greater__wrapper::*default_GetCellRegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetCellRegularGridValues"
                , GetCellRegularGridValues_function_type(&::DiscreteSource< 3 >::GetCellRegularGridValues)
                , default_GetCellRegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetCellRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetMeshValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetMeshValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetMeshValues"
                , GetMeshValues_function_type( &::DiscreteSource< 3 >::GetMeshValues ) );
        
        }
        { //::DiscreteSource< 3 >::GetPointRegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetPointRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( DiscreteSource_less__3__greater__wrapper::*default_GetPointRegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetPointRegularGridValues"
                , GetPointRegularGridValues_function_type(&::DiscreteSource< 3 >::GetPointRegularGridValues)
                , default_GetPointRegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetPointRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetRegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetRegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetRegularGridValues"
                , GetRegularGridValues_function_type( &::DiscreteSource< 3 >::GetRegularGridValues ) );
        
        }
        { //::DiscreteSource< 3 >::GetSolutionDependentRegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionDependentRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( DiscreteSource_less__3__greater__wrapper::*default_GetSolutionDependentRegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetSolutionDependentRegularGridValues"
                , GetSolutionDependentRegularGridValues_function_type(&::DiscreteSource< 3 >::GetSolutionDependentRegularGridValues)
                , default_GetSolutionDependentRegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetSolutionDependentRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetType
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::SourceType::Value ( exported_class_t::*GetType_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetType"
                , GetType_function_type( &::DiscreteSource< 3 >::GetType ) );
        
        }
        { //::DiscreteSource< 3 >::GetVesselRegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetVesselRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( DiscreteSource_less__3__greater__wrapper::*default_GetVesselRegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetVesselRegularGridValues"
                , GetVesselRegularGridValues_function_type(&::DiscreteSource< 3 >::GetVesselRegularGridValues)
                , default_GetVesselRegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetVesselRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::IsLinearInSolution
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsLinearInSolution_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "IsLinearInSolution"
                , IsLinearInSolution_function_type( &::DiscreteSource< 3 >::IsLinearInSolution ) );
        
        }
        { //::DiscreteSource< 3 >::SetIsLinearInSolution
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsLinearInSolution_function_type)( bool ) ;
            
            DiscreteSource3_exposer.def( 
                "SetIsLinearInSolution"
                , SetIsLinearInSolution_function_type( &::DiscreteSource< 3 >::SetIsLinearInSolution )
                , ( bp::arg("isLinear") ) );
        
        }
        { //::DiscreteSource< 3 >::SetLabelName
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteSource3_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteSource< 3 >::SetLabelName )
                , ( bp::arg("rLabel") ) );
        
        }
        { //::DiscreteSource< 3 >::SetMesh
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteSource< 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteSource< 3 >::SetPoints
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteSource< 3 >::SetPoints )
                , ( bp::arg("points") ) );
        
        }
        { //::DiscreteSource< 3 >::SetRegularGrid
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteSource< 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::DiscreteSource< 3 >::SetSolution
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSolution_function_type)( ::std::vector< double > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetSolution"
                , SetSolution_function_type( &::DiscreteSource< 3 >::SetSolution )
                , ( bp::arg("solution") ) );
        
        }
        { //::DiscreteSource< 3 >::SetSource
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSource_function_type)( ::SourceStrength::Value ) ;
            
            DiscreteSource3_exposer.def( 
                "SetSource"
                , SetSource_function_type( &::DiscreteSource< 3 >::SetSource )
                , ( bp::arg("boundarySource") ) );
        
        }
        { //::DiscreteSource< 3 >::SetType
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetType_function_type)( ::SourceType::Value ) ;
            
            DiscreteSource3_exposer.def( 
                "SetType"
                , SetType_function_type( &::DiscreteSource< 3 >::SetType )
                , ( bp::arg("boundaryType") ) );
        
        }
        { //::DiscreteSource< 3 >::SetValue
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetValue_function_type)( double ) ;
            
            DiscreteSource3_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::DiscreteSource< 3 >::SetValue )
                , ( bp::arg("value") ) );
        
        }
        DiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteSource<3> > >();
    }

    { //::CellStateDependentDiscreteSource< 3 >
        typedef bp::class_< CellStateDependentDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > CellStateDependentDiscreteSource3_exposer_t;
        CellStateDependentDiscreteSource3_exposer_t CellStateDependentDiscreteSource3_exposer = CellStateDependentDiscreteSource3_exposer_t( "CellStateDependentDiscreteSource3", bp::init< >() );
        bp::scope CellStateDependentDiscreteSource3_scope( CellStateDependentDiscreteSource3_exposer );
        { //::CellStateDependentDiscreteSource< 3 >::Create
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< CellStateDependentDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::CellStateDependentDiscreteSource< 3 >::Create ) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetCellRegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetCellRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetCellRegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetCellRegularGridValues"
                , GetCellRegularGridValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetCellRegularGridValues)
                , default_GetCellRegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetCellRegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::SetStateRateMap
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateMap_function_type)( ::std::map< unsigned int, double > ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "SetStateRateMap"
                , SetStateRateMap_function_type( &::CellStateDependentDiscreteSource< 3 >::SetStateRateMap )
                , ( bp::arg("stateRateMap") ) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::SetStateRateThresholdMap
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateThresholdMap_function_type)( ::std::map< unsigned int, double > ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "SetStateRateThresholdMap"
                , SetStateRateThresholdMap_function_type( &::CellStateDependentDiscreteSource< 3 >::SetStateRateThresholdMap )
                , ( bp::arg("stateThresholdMap") ) );
        
        }
        { //::DiscreteSource< 3 >::GetPointRegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetPointRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetPointRegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetPointRegularGridValues"
                , GetPointRegularGridValues_function_type(&::DiscreteSource< 3 >::GetPointRegularGridValues)
                , default_GetPointRegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetPointRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetSolutionDependentRegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionDependentRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetSolutionDependentRegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetSolutionDependentRegularGridValues"
                , GetSolutionDependentRegularGridValues_function_type(&::DiscreteSource< 3 >::GetSolutionDependentRegularGridValues)
                , default_GetSolutionDependentRegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetSolutionDependentRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetVesselRegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetVesselRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< double > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetVesselRegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetVesselRegularGridValues"
                , GetVesselRegularGridValues_function_type(&::DiscreteSource< 3 >::GetVesselRegularGridValues)
                , default_GetVesselRegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetVesselRegularGridValues) );
        
        }
        CellStateDependentDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellStateDependentDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellStateDependentDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::FiniteDifferenceSolver< 3 >
        typedef bp::class_< FiniteDifferenceSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > > FiniteDifferenceSolver3_exposer_t;
        FiniteDifferenceSolver3_exposer_t FiniteDifferenceSolver3_exposer = FiniteDifferenceSolver3_exposer_t( "FiniteDifferenceSolver3", bp::init< >() );
        bp::scope FiniteDifferenceSolver3_scope( FiniteDifferenceSolver3_exposer );
        { //::FiniteDifferenceSolver< 3 >::Create
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteDifferenceSolver< 3 > > ( *Create_function_type )(  );
            
            FiniteDifferenceSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::FiniteDifferenceSolver< 3 >::Create ) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ( exported_class_t::*GetRGBoundaryConditions_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetRGBoundaryConditions"
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions ) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Setup
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Setup"
                , Setup_function_type(&::FiniteDifferenceSolver< 3 >::Setup)
                , default_Setup_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Solve
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteDifferenceSolver< 3 >::Solve)
                , default_Solve_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Update
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteDifferenceSolver< 3 >::Update)
                , default_Update_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Update) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::UpdateBoundaryConditionsEachSolve
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionsEachSolve_function_type)( bool ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateBoundaryConditionsEachSolve"
                , UpdateBoundaryConditionsEachSolve_function_type( &::FiniteDifferenceSolver< 3 >::UpdateBoundaryConditionsEachSolve )
                , ( bp::arg("doUpdate") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetPointSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetPointSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetPointSolution"
                , GetPointSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution)
                , default_GetPointSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetPointSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionAtGridPoints_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolutionAtGridPoints_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolutionAtGridPoints"
                , GetSolutionAtGridPoints_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints)
                , default_GetSolutionAtGridPoints_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolutionAtGridPoints)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionAtPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolutionAtPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolutionAtPoints"
                , GetSolutionAtPoints_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints)
                , default_GetSolutionAtPoints_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolutionAtPoints)
                , ( bp::arg("samplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("data") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Write) );
        
        }
        FiniteDifferenceSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteDifferenceSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::FiniteElementSolver< 3 >
        typedef bp::class_< FiniteElementSolver_less__3__greater__wrapper > FiniteElementSolver3_exposer_t;
        FiniteElementSolver3_exposer_t FiniteElementSolver3_exposer = FiniteElementSolver3_exposer_t( "FiniteElementSolver3", bp::init< >() );
        bp::scope FiniteElementSolver3_scope( FiniteElementSolver3_exposer );
        { //::FiniteElementSolver< 3 >::Create
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteElementSolver< 3 > > ( *Create_function_type )(  );
            
            FiniteElementSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::FiniteElementSolver< 3 >::Create ) );
        
        }
        { //::FiniteElementSolver< 3 >::GetNodalSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetNodalSolution_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetNodalSolution"
                , GetNodalSolution_function_type( &::FiniteElementSolver< 3 >::GetNodalSolution ) );
        
        }
        { //::FiniteElementSolver< 3 >::GetSolutionAtGridPoints
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionAtGridPoints_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolutionAtGridPoints_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolutionAtGridPoints"
                , GetSolutionAtGridPoints_function_type(&::FiniteElementSolver< 3 >::GetSolutionAtGridPoints)
                , default_GetSolutionAtGridPoints_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolutionAtGridPoints)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::FiniteElementSolver< 3 >::GetSolutionAtPoints
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionAtPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolutionAtPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolutionAtPoints"
                , GetSolutionAtPoints_function_type(&::FiniteElementSolver< 3 >::GetSolutionAtPoints)
                , default_GetSolutionAtPoints_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolutionAtPoints)
                , ( bp::arg("samplePoints") ) );
        
        }
        { //::FiniteElementSolver< 3 >::ReadSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*ReadSolution_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "ReadSolution"
                , ReadSolution_function_type( &::FiniteElementSolver< 3 >::ReadSolution ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetGuess
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGuess_function_type)( ::std::vector< double > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetGuess"
                , SetGuess_function_type( &::FiniteElementSolver< 3 >::SetGuess )
                , ( bp::arg("guess") ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetMesh
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::FiniteElementSolver< 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetUseLinearSolveForGuess
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseLinearSolveForGuess_function_type)( bool ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetUseLinearSolveForGuess"
                , SetUseLinearSolveForGuess_function_type( &::FiniteElementSolver< 3 >::SetUseLinearSolveForGuess )
                , ( bp::arg("useLinearSolve")=(bool)(true) ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetUseSimpleNetonSolver
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSimpleNetonSolver_function_type)( bool ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetUseSimpleNetonSolver"
                , SetUseSimpleNetonSolver_function_type( &::FiniteElementSolver< 3 >::SetUseSimpleNetonSolver )
                , ( bp::arg("useNewton")=(bool)(true) ) );
        
        }
        { //::FiniteElementSolver< 3 >::Setup
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Setup"
                , Setup_function_type(&::FiniteElementSolver< 3 >::Setup)
                , default_Setup_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::FiniteElementSolver< 3 >::Solve
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteElementSolver< 3 >::Solve)
                , default_Solve_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteElementSolver< 3 >::Update
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteElementSolver< 3 >::Update)
                , default_Update_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Update) );
        
        }
        { //::FiniteElementSolver< 3 >::UpdateCellData
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::FiniteElementSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        FiniteElementSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteElementSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::FunctionMap< 3 >
        typedef bp::class_< FunctionMap_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > > FunctionMap3_exposer_t;
        FunctionMap3_exposer_t FunctionMap3_exposer = FunctionMap3_exposer_t( "FunctionMap3", bp::init< >() );
        bp::scope FunctionMap3_scope( FunctionMap3_exposer );
        { //::FunctionMap< 3 >::Create
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FunctionMap< 3 > > ( *Create_function_type )(  );
            
            FunctionMap3_exposer.def( 
                "Create"
                , Create_function_type( &::FunctionMap< 3 >::Create ) );
        
        }
        { //::FunctionMap< 3 >::Solve
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FunctionMap< 3 >::Solve)
                , default_Solve_function_type(&FunctionMap_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetPointSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetPointSolution_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetPointSolution"
                , GetPointSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution)
                , default_GetPointSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetPointSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionAtGridPoints_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolutionAtGridPoints_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolutionAtGridPoints"
                , GetSolutionAtGridPoints_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints)
                , default_GetSolutionAtGridPoints_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolutionAtGridPoints)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolutionAtPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolutionAtPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolutionAtPoints"
                , GetSolutionAtPoints_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints)
                , default_GetSolutionAtPoints_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolutionAtPoints)
                , ( bp::arg("samplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FunctionMap_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
                , default_Setup_function_type(&FunctionMap_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Update"
                , Update_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
                , default_Update_function_type(&FunctionMap_less__3__greater__wrapper::default_Update) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("data") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FunctionMap_less__3__greater__wrapper::default_Write) );
        
        }
        FunctionMap3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FunctionMap<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    bp::class_< GreensFunctionSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > >( "GreensFunctionSolver3", bp::init< >() )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<3>::* )( double ))( &::GreensFunctionSolver< 3 >::SetSubSegmentCutoff )
            , ( bp::arg("value") ) )    
        .def( 
            "Solve"
            , (void ( ::GreensFunctionSolver<3>::* )(  ))(&::GreensFunctionSolver< 3 >::Solve)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Solve) )    
        .def( 
            "GetPointSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetPointSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetPointSolution) )    
        .def( 
            "GetSolutionAtGridPoints"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtGridPoints)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3, 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolutionAtGridPoints)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolutionAtPoints"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolutionAtPoints)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolutionAtPoints)
            , ( bp::arg("samplePoints") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< double > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("data") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Write) );

    { //::DiscreteContinuumBoundaryCondition< 3 >
        typedef bp::class_< DiscreteContinuumBoundaryCondition< 3 > > DiscreteContinuumBoundaryCondition3_exposer_t;
        DiscreteContinuumBoundaryCondition3_exposer_t DiscreteContinuumBoundaryCondition3_exposer = DiscreteContinuumBoundaryCondition3_exposer_t( "DiscreteContinuumBoundaryCondition3", bp::init< >() );
        bp::scope DiscreteContinuumBoundaryCondition3_scope( DiscreteContinuumBoundaryCondition3_exposer );
        { //::DiscreteContinuumBoundaryCondition< 3 >::Create
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 3 > > ( *Create_function_type )(  );
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::Create ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetType
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::BoundaryConditionType::Value ( exported_class_t::*GetType_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetType"
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetType ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetValue_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::std::pair< bool, double > ( exported_class_t::*GetValue_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue )
                , ( bp::arg("location"), bp::arg("tolerance") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetDomain
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDomain_function_type)( ::boost::shared_ptr< Part< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetDomain"
                , SetDomain_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetDomain )
                , ( bp::arg("pDomain") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetLabelName
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetLabelName )
                , ( bp::arg("label") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetMesh
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetNetwork
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetPoints
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetPoints )
                , ( bp::arg("points") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetRegularGrid
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetSource
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSource_function_type)( ::BoundaryConditionSource::Value ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetSource"
                , SetSource_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetSource )
                , ( bp::arg("boundarySource") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetType
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetType_function_type)( ::BoundaryConditionType::Value ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetType"
                , SetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetType )
                , ( bp::arg("boundaryType") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetValue_function_type)( double ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateBoundaryConditionContainer
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionContainer_function_type)( ::boost::shared_ptr< BoundaryConditionsContainer< 3, 3, 1 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateBoundaryConditionContainer"
                , UpdateBoundaryConditionContainer_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateBoundaryConditionContainer )
                , ( bp::arg("pContainer") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridBoundaryConditions"
                , UpdateRegularGridBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridCellBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridCellBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridCellBoundaryConditions"
                , UpdateRegularGridCellBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridCellBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridFacetBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridFacetBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridFacetBoundaryConditions"
                , UpdateRegularGridFacetBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridFacetBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPartBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPartBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridPartBoundaryConditions"
                , UpdateRegularGridPartBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPartBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPointBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPointBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridPointBoundaryConditions"
                , UpdateRegularGridPointBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPointBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridSegmentBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridSegmentBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, double> > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridSegmentBoundaryConditions"
                , UpdateRegularGridSegmentBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridSegmentBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        DiscreteContinuumBoundaryCondition3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumBoundaryCondition<3> > >();
    }

    { //::DiscreteContinuumLinearEllipticPde< 3, 3 >
        typedef bp::class_< DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper, bp::bases< AbstractLinearEllipticPde< 3, 3 > > > DiscreteContinuumLinearEllipticPde3_3_exposer_t;
        DiscreteContinuumLinearEllipticPde3_3_exposer_t DiscreteContinuumLinearEllipticPde3_3_exposer = DiscreteContinuumLinearEllipticPde3_3_exposer_t( "DiscreteContinuumLinearEllipticPde3_3", bp::init< >() );
        bp::scope DiscreteContinuumLinearEllipticPde3_3_scope( DiscreteContinuumLinearEllipticPde3_3_exposer );
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::AddDiscreteSource
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::Create
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 3, 3 > > ( *Create_function_type )(  );
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::Create ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::GetVariableName
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::string const & ( exported_class_t::*GetVariableName_function_type)(  ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "GetVariableName"
                , GetVariableName_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::GetVariableName )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( double ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( double ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( double ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetMesh
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< TetrahedralMesh< 3, 3 > > ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetRegularGrid
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetUseRegularGrid
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetVariableName
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVariableName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetVariableName"
                , SetVariableName_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetVariableName )
                , ( bp::arg("rVariableName") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths ) );
        
        }
        { //::AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTermAtNode_function_type)( ::Node< 3 > const & ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTermAtNode_function_type)( ::Node< 3 > const & ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTermAtNode"
                , ComputeConstantInUSourceTermAtNode_function_type(&::AbstractLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTermAtNode)
                , default_ComputeConstantInUSourceTermAtNode_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTermAtNode)
                , ( bp::arg("rNode") ) );
        
        }
        { //::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTermAtNode_function_type)( ::Node< 3 > const & ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTermAtNode_function_type)( ::Node< 3 > const & ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTermAtNode"
                , ComputeLinearInUCoeffInSourceTermAtNode_function_type(&::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTermAtNode)
                , default_ComputeLinearInUCoeffInSourceTermAtNode_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTermAtNode)
                , ( bp::arg("rNode") ) );
        
        }
        DiscreteContinuumLinearEllipticPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearEllipticPde< 3, 3 > > >();
    }

    { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >
        typedef bp::class_< DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper > DiscreteContinuumNonLinearEllipticPde3_3_exposer_t;
        DiscreteContinuumNonLinearEllipticPde3_3_exposer_t DiscreteContinuumNonLinearEllipticPde3_3_exposer = DiscreteContinuumNonLinearEllipticPde3_3_exposer_t( "DiscreteContinuumNonLinearEllipticPde3_3", bp::init< >() );
        bp::scope DiscreteContinuumNonLinearEllipticPde3_3_scope( DiscreteContinuumNonLinearEllipticPde3_3_exposer );
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::AddDiscreteSource
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0"), bp::arg("u") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTermPrime
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTermPrime"
                , ComputeDiffusionTermPrime_function_type(&::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeDiffusionTermPrime)
                , default_ComputeDiffusionTermPrime_function_type(&DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef double ( DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearSourceTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearSourceTerm"
                , ComputeLinearSourceTerm_function_type(&::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearSourceTerm)
                , default_ComputeLinearSourceTerm_function_type(&DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearSourceTerm)
                , ( bp::arg("rX") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef double ( DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef double ( DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&DiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::Create
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumNonLinearEllipticPde< 3, 3 > > ( *Create_function_type )(  );
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::Create ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetThreshold
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetThreshold_function_type)(  ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "GetThreshold"
                , GetThreshold_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetThreshold ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetVariableName
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::string const & ( exported_class_t::*GetVariableName_function_type)(  ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "GetVariableName"
                , GetVariableName_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetVariableName )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetMesh
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< TetrahedralMesh< 3, 3 > > ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetRegularGrid
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetThreshold
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetThreshold_function_type)( double ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetThreshold"
                , SetThreshold_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetThreshold )
                , ( bp::arg("threshold") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetUseRegularGrid
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetVariableName
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVariableName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetVariableName"
                , SetVariableName_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetVariableName )
                , ( bp::arg("rVariableName") ) );
        
        }
        { //::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef DiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            DiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type( &::DiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths ) );
        
        }
        DiscreteContinuumNonLinearEllipticPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumNonLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumNonLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 3 > > >();
    }

    { //::chaste::pde::Instantiation
    
        typedef int ( *Instantiation_function_type )(  );
        
        bp::def( 
            "Instantiation"
            , Instantiation_function_type( &::chaste::pde::Instantiation ) );
    
    }
}

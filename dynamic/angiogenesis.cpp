// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "angiogenesis_headers.hpp"

namespace bp = boost::python;

struct AbstractMigrationRule_less__3__greater__wrapper : AbstractMigrationRule< 3 >, bp::wrapper< AbstractMigrationRule< 3 > > {

    AbstractMigrationRule_less__3__greater__wrapper(AbstractMigrationRule<3> const & arg )
    : AbstractMigrationRule<3>( arg )
      , bp::wrapper< AbstractMigrationRule< 3 > >(){
        // copy constructor
        
    }

    AbstractMigrationRule_less__3__greater__wrapper( )
    : AbstractMigrationRule<3>( )
      , bp::wrapper< AbstractMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::numeric::ublas::c_vector<double, 3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::numeric::ublas::c_vector<double, 3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

};

struct AbstractSproutingRule_less__3__greater__wrapper : AbstractSproutingRule< 3 >, bp::wrapper< AbstractSproutingRule< 3 > > {

    AbstractSproutingRule_less__3__greater__wrapper(AbstractSproutingRule<3> const & arg )
    : AbstractSproutingRule<3>( arg )
      , bp::wrapper< AbstractSproutingRule< 3 > >(){
        // copy constructor
        
    }

    AbstractSproutingRule_less__3__greater__wrapper( )
    : AbstractSproutingRule<3>( )
      , bp::wrapper< AbstractSproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->AbstractSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->AbstractSproutingRule< 3 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        AbstractSproutingRule< 3 >::SetGrid( pGrid );
    }

};

struct AngiogenesisSolver_less__3__greater__wrapper : AngiogenesisSolver< 3 >, bp::wrapper< AngiogenesisSolver< 3 > > {

    AngiogenesisSolver_less__3__greater__wrapper(AngiogenesisSolver<3> const & arg )
    : AngiogenesisSolver<3>( arg )
      , bp::wrapper< AngiogenesisSolver< 3 > >(){
        // copy constructor
        
    }

    AngiogenesisSolver_less__3__greater__wrapper( )
    : AngiogenesisSolver<3>( )
      , bp::wrapper< AngiogenesisSolver< 3 > >(){
        // null constructor
    
    }

    virtual void DoAnastamosis(  ){
        if( bp::override func_DoAnastamosis = this->get_override( "DoAnastamosis" ) )
            func_DoAnastamosis(  );
        else{
            this->AngiogenesisSolver< 3 >::DoAnastamosis(  );
        }
    }
    
    virtual void default_DoAnastamosis(  ){
        AngiogenesisSolver< 3 >::DoAnastamosis( );
    }

    virtual void DoSprouting(  ){
        if( bp::override func_DoSprouting = this->get_override( "DoSprouting" ) )
            func_DoSprouting(  );
        else{
            this->AngiogenesisSolver< 3 >::DoSprouting(  );
        }
    }
    
    virtual void default_DoSprouting(  ){
        AngiogenesisSolver< 3 >::DoSprouting( );
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->AngiogenesisSolver< 3 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        AngiogenesisSolver< 3 >::Increment( );
    }

    virtual void UpdateNodalPositions( bool sprouting=false ){
        if( bp::override func_UpdateNodalPositions = this->get_override( "UpdateNodalPositions" ) )
            func_UpdateNodalPositions( sprouting );
        else{
            this->AngiogenesisSolver< 3 >::UpdateNodalPositions( sprouting );
        }
    }
    
    virtual void default_UpdateNodalPositions( bool sprouting=false ){
        AngiogenesisSolver< 3 >::UpdateNodalPositions( sprouting );
    }

};

struct OffLatticeMigrationRule_less__3__greater__wrapper : OffLatticeMigrationRule< 3 >, bp::wrapper< OffLatticeMigrationRule< 3 > > {

    OffLatticeMigrationRule_less__3__greater__wrapper(OffLatticeMigrationRule<3> const & arg )
    : OffLatticeMigrationRule<3>( arg )
      , bp::wrapper< OffLatticeMigrationRule< 3 > >(){
        // copy constructor
        
    }

    OffLatticeMigrationRule_less__3__greater__wrapper( )
    : OffLatticeMigrationRule<3>( )
      , bp::wrapper< OffLatticeMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::numeric::ublas::c_vector<double, 3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->OffLatticeMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::numeric::ublas::c_vector<double, 3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return OffLatticeMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

};

struct OffLatticeSproutingRule_less__3__greater__wrapper : OffLatticeSproutingRule< 3 >, bp::wrapper< OffLatticeSproutingRule< 3 > > {

    OffLatticeSproutingRule_less__3__greater__wrapper(OffLatticeSproutingRule<3> const & arg )
    : OffLatticeSproutingRule<3>( arg )
      , bp::wrapper< OffLatticeSproutingRule< 3 > >(){
        // copy constructor
        
    }

    OffLatticeSproutingRule_less__3__greater__wrapper( )
    : OffLatticeSproutingRule<3>( )
      , bp::wrapper< OffLatticeSproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->OffLatticeSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return OffLatticeSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->AbstractSproutingRule< 3 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 3, 3 > > pGrid ) {
        AbstractSproutingRule< 3 >::SetGrid( pGrid );
    }

};

struct Owen2011MigrationRule_less__3__greater__wrapper : Owen2011MigrationRule< 3 >, bp::wrapper< Owen2011MigrationRule< 3 > > {

    Owen2011MigrationRule_less__3__greater__wrapper(Owen2011MigrationRule<3> const & arg )
    : Owen2011MigrationRule<3>( arg )
      , bp::wrapper< Owen2011MigrationRule< 3 > >(){
        // copy constructor
        
    }

    Owen2011MigrationRule_less__3__greater__wrapper( )
    : Owen2011MigrationRule<3>( )
      , bp::wrapper< Owen2011MigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->Owen2011MigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return Owen2011MigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< boost::numeric::ublas::c_vector<double, 3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::numeric::ublas::c_vector<double, 3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

};

struct Owen2011SproutingRule_less__3__greater__wrapper : Owen2011SproutingRule< 3 >, bp::wrapper< Owen2011SproutingRule< 3 > > {

    Owen2011SproutingRule_less__3__greater__wrapper(Owen2011SproutingRule<3> const & arg )
    : Owen2011SproutingRule<3>( arg )
      , bp::wrapper< Owen2011SproutingRule< 3 > >(){
        // copy constructor
        
    }

    Owen2011SproutingRule_less__3__greater__wrapper( )
    : Owen2011SproutingRule<3>( )
      , bp::wrapper< Owen2011SproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->Owen2011SproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return Owen2011SproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::numeric::ublas::c_vector< double, 3 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselNode< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(_chaste_project_Angiogenesis_angiogenesis){
    { //::std::vector< int >
        typedef bp::class_< std::vector< int > > vector_less__int__greater__exposer_t;
        vector_less__int__greater__exposer_t vector_less__int__greater__exposer = vector_less__int__greater__exposer_t( "vector_less__int__greater_" );
        bp::scope vector_less__int__greater__scope( vector_less__int__greater__exposer );
        vector_less__int__greater__exposer.def( bp::indexing::vector_suite< std::vector< int > >() );
    }

    { //::std::vector< boost::shared_ptr<VesselNode<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselNode<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselNode<3> > > >() );
    }

    { //::std::vector< boost::numeric::ublas::c_vector<double, 3> >
        typedef bp::class_< std::vector< boost::numeric::ublas::c_vector<double, 3> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::numeric::ublas::c_vector<double, 3> > >() );
    }

    { //::AbstractMigrationRule< 3 >
        typedef bp::class_< AbstractMigrationRule_less__3__greater__wrapper > AbstractMigrationRule3_exposer_t;
        AbstractMigrationRule3_exposer_t AbstractMigrationRule3_exposer = AbstractMigrationRule3_exposer_t( "AbstractMigrationRule3", bp::init< >() );
        bp::scope AbstractMigrationRule3_scope( AbstractMigrationRule3_exposer );
        { //::AbstractMigrationRule< 3 >::Create
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< AbstractMigrationRule< 3 > > ( *Create_function_type )(  );
            
            AbstractMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::AbstractMigrationRule< 3 >::Create ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( AbstractMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&AbstractMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetIndices
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( AbstractMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::AbstractMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&AbstractMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetCellPopulation
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellPopulation_function_type)( ::boost::shared_ptr< AbstractCellPopulation< 3, 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetCellPopulation"
                , SetCellPopulation_function_type( &::AbstractMigrationRule< 3 >::SetCellPopulation )
                , ( bp::arg("pCellPopulation") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetDiscreteContinuumSolver
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDiscreteContinuumSolver_function_type)( ::boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetDiscreteContinuumSolver"
                , SetDiscreteContinuumSolver_function_type( &::AbstractMigrationRule< 3 >::SetDiscreteContinuumSolver )
                , ( bp::arg("pSolver") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetGrid
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type( &::AbstractMigrationRule< 3 >::SetGrid )
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetIsSprouting
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsSprouting_function_type)( bool ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetIsSprouting"
                , SetIsSprouting_function_type( &::AbstractMigrationRule< 3 >::SetIsSprouting )
                , ( bp::arg("isSprouting")=(bool)(true) ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetNetwork
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::AbstractMigrationRule< 3 >::SetNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        AbstractMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< AbstractMigrationRule<3> > >();
    }

    { //::AbstractSproutingRule< 3 >
        typedef bp::class_< AbstractSproutingRule_less__3__greater__wrapper > AbstractSproutingRule3_exposer_t;
        AbstractSproutingRule3_exposer_t AbstractSproutingRule3_exposer = AbstractSproutingRule3_exposer_t( "AbstractSproutingRule3", bp::init< >() );
        bp::scope AbstractSproutingRule3_scope( AbstractSproutingRule3_exposer );
        { //::AbstractSproutingRule< 3 >::GetSprouts
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( AbstractSproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::AbstractSproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&AbstractSproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetDiscreteContinuumSolver
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDiscreteContinuumSolver_function_type)( ::boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetDiscreteContinuumSolver"
                , SetDiscreteContinuumSolver_function_type( &::AbstractSproutingRule< 3 >::SetDiscreteContinuumSolver )
                , ( bp::arg("pSolver") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetGrid
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            typedef void ( AbstractSproutingRule_less__3__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::AbstractSproutingRule< 3 >::SetGrid)
                , default_SetGrid_function_type(&AbstractSproutingRule_less__3__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetSproutingProbability
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingProbability_function_type)( double ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetSproutingProbability"
                , SetSproutingProbability_function_type( &::AbstractSproutingRule< 3 >::SetSproutingProbability )
                , ( bp::arg("probability") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetVesselEndCutoff
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselEndCutoff_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetVesselEndCutoff"
                , SetVesselEndCutoff_function_type( &::AbstractSproutingRule< 3 >::SetVesselEndCutoff )
                , ( bp::arg("cutoff") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetVesselNetwork
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::AbstractSproutingRule< 3 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractSproutingRule<3> > >();
    }

    { //::AngiogenesisSolver< 3 >
        typedef bp::class_< AngiogenesisSolver_less__3__greater__wrapper > AngiogenesisSolver3_exposer_t;
        AngiogenesisSolver3_exposer_t AngiogenesisSolver3_exposer = AngiogenesisSolver3_exposer_t( "AngiogenesisSolver3", bp::init< >() );
        bp::scope AngiogenesisSolver3_scope( AngiogenesisSolver3_exposer );
        { //::AngiogenesisSolver< 3 >::Create
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< AngiogenesisSolver< 3 > > ( *Create_function_type )(  );
            
            AngiogenesisSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::AngiogenesisSolver< 3 >::Create ) );
        
        }
        { //::AngiogenesisSolver< 3 >::DoAnastamosis
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*DoAnastamosis_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "DoAnastamosis"
                , DoAnastamosis_function_type( &AngiogenesisSolver_less__3__greater__wrapper::default_DoAnastamosis ) );
        
        }
        { //::AngiogenesisSolver< 3 >::DoSprouting
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*DoSprouting_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "DoSprouting"
                , DoSprouting_function_type( &AngiogenesisSolver_less__3__greater__wrapper::default_DoSprouting ) );
        
        }
        { //::AngiogenesisSolver< 3 >::Increment
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Increment_function_type)(  ) ;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*default_Increment_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "Increment"
                , Increment_function_type(&::AngiogenesisSolver< 3 >::Increment)
                , default_Increment_function_type(&AngiogenesisSolver_less__3__greater__wrapper::default_Increment) );
        
        }
        { //::AngiogenesisSolver< 3 >::IsSproutingRuleSet
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsSproutingRuleSet_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "IsSproutingRuleSet"
                , IsSproutingRuleSet_function_type( &::AngiogenesisSolver< 3 >::IsSproutingRuleSet ) );
        
        }
        { //::AngiogenesisSolver< 3 >::Run
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Run_function_type)( bool ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "Run"
                , Run_function_type( &::AngiogenesisSolver< 3 >::Run )
                , ( bp::arg("writeOutput")=(bool)(false) ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetAnastamosisRadius
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetAnastamosisRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetAnastamosisRadius"
                , SetAnastamosisRadius_function_type( &::AngiogenesisSolver< 3 >::SetAnastamosisRadius )
                , ( bp::arg("radius") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetBoundingDomain
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetBoundingDomain_function_type)( ::boost::shared_ptr< Part< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetBoundingDomain"
                , SetBoundingDomain_function_type( &::AngiogenesisSolver< 3 >::SetBoundingDomain )
                , ( bp::arg("pDomain") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetCellPopulation
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellPopulation_function_type)( ::boost::shared_ptr< AbstractCellPopulation< 3, 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetCellPopulation"
                , SetCellPopulation_function_type( &::AngiogenesisSolver< 3 >::SetCellPopulation )
                , ( bp::arg("pCellPopulation") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetMigrationRule
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMigrationRule_function_type)( ::boost::shared_ptr< AbstractMigrationRule< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetMigrationRule"
                , SetMigrationRule_function_type( &::AngiogenesisSolver< 3 >::SetMigrationRule )
                , ( bp::arg("pMigrationRule") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetOutputFileHandler
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputFileHandler_function_type)( ::boost::shared_ptr< OutputFileHandler > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetOutputFileHandler"
                , SetOutputFileHandler_function_type( &::AngiogenesisSolver< 3 >::SetOutputFileHandler )
                , ( bp::arg("pHandler") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetSproutingRule
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingRule_function_type)( ::boost::shared_ptr< AbstractSproutingRule< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetSproutingRule"
                , SetSproutingRule_function_type( &::AngiogenesisSolver< 3 >::SetSproutingRule )
                , ( bp::arg("pSproutingRule") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetVesselGrid
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetVesselGrid"
                , SetVesselGrid_function_type( &::AngiogenesisSolver< 3 >::SetVesselGrid )
                , ( bp::arg("pVesselGrid") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetVesselNetwork
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::AngiogenesisSolver< 3 >::SetVesselNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::UpdateNodalPositions
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*UpdateNodalPositions_function_type)( bool ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "UpdateNodalPositions"
                , UpdateNodalPositions_function_type( &AngiogenesisSolver_less__3__greater__wrapper::default_UpdateNodalPositions )
                , ( bp::arg("sprouting")=(bool)(false) ) );
        
        }
        AngiogenesisSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< AngiogenesisSolver<3> > >();
    }

    { //::OffLatticeMigrationRule< 3 >
        typedef bp::class_< OffLatticeMigrationRule_less__3__greater__wrapper, bp::bases< AbstractMigrationRule< 3 > > > OffLatticeMigrationRule3_exposer_t;
        OffLatticeMigrationRule3_exposer_t OffLatticeMigrationRule3_exposer = OffLatticeMigrationRule3_exposer_t( "OffLatticeMigrationRule3", bp::init< >() );
        bp::scope OffLatticeMigrationRule3_scope( OffLatticeMigrationRule3_exposer );
        { //::OffLatticeMigrationRule< 3 >::Create
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< OffLatticeMigrationRule< 3 > > ( *Create_function_type )(  );
            
            OffLatticeMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::OffLatticeMigrationRule< 3 >::Create ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::GetDirections
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( OffLatticeMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::OffLatticeMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&OffLatticeMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::GetDirectionsForSprouts
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( exported_class_t::*GetDirectionsForSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "GetDirectionsForSprouts"
                , GetDirectionsForSprouts_function_type( &::OffLatticeMigrationRule< 3 >::GetDirectionsForSprouts )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetAttractionStrength
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetAttractionStrength_function_type)( double ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetAttractionStrength"
                , SetAttractionStrength_function_type( &::OffLatticeMigrationRule< 3 >::SetAttractionStrength )
                , ( bp::arg("strength") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetChemotacticStrength
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetChemotacticStrength_function_type)( double ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetChemotacticStrength"
                , SetChemotacticStrength_function_type( &::OffLatticeMigrationRule< 3 >::SetChemotacticStrength )
                , ( bp::arg("strength") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetIsSprouting
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsSprouting_function_type)( bool ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetIsSprouting"
                , SetIsSprouting_function_type( &::OffLatticeMigrationRule< 3 >::SetIsSprouting )
                , ( bp::arg("isSprouting")=(bool)(true) ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetSproutingVelocity
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingVelocity_function_type)( double ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetSproutingVelocity"
                , SetSproutingVelocity_function_type( &::OffLatticeMigrationRule< 3 >::SetSproutingVelocity )
                , ( bp::arg("velocity") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetIndices
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( OffLatticeMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::AbstractMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&OffLatticeMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        OffLatticeMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< OffLatticeMigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< OffLatticeMigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
    }

    { //::OffLatticeSproutingRule< 3 >
        typedef bp::class_< OffLatticeSproutingRule_less__3__greater__wrapper, bp::bases< AbstractSproutingRule< 3 > > > OffLatticeSproutingRule3_exposer_t;
        OffLatticeSproutingRule3_exposer_t OffLatticeSproutingRule3_exposer = OffLatticeSproutingRule3_exposer_t( "OffLatticeSproutingRule3", bp::init< >() );
        bp::scope OffLatticeSproutingRule3_scope( OffLatticeSproutingRule3_exposer );
        { //::OffLatticeSproutingRule< 3 >::Create
        
            typedef OffLatticeSproutingRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< OffLatticeSproutingRule< 3 > > ( *Create_function_type )(  );
            
            OffLatticeSproutingRule3_exposer.def( 
                "Create"
                , Create_function_type( &::OffLatticeSproutingRule< 3 >::Create ) );
        
        }
        { //::OffLatticeSproutingRule< 3 >::GetSprouts
        
            typedef OffLatticeSproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( OffLatticeSproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeSproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::OffLatticeSproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&OffLatticeSproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetGrid
        
            typedef OffLatticeSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            typedef void ( OffLatticeSproutingRule_less__3__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3, 3 > > ) ;
            
            OffLatticeSproutingRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::AbstractSproutingRule< 3 >::SetGrid)
                , default_SetGrid_function_type(&OffLatticeSproutingRule_less__3__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        OffLatticeSproutingRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< OffLatticeSproutingRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< OffLatticeSproutingRule< 3 > >, boost::shared_ptr< AbstractSproutingRule< 3 > > >();
    }

    { //::Owen2011MigrationRule< 3 >
        typedef bp::class_< Owen2011MigrationRule_less__3__greater__wrapper > Owen2011MigrationRule3_exposer_t;
        Owen2011MigrationRule3_exposer_t Owen2011MigrationRule3_exposer = Owen2011MigrationRule3_exposer_t( "Owen2011MigrationRule3", bp::init< >() );
        bp::scope Owen2011MigrationRule3_scope( Owen2011MigrationRule3_exposer );
        { //::Owen2011MigrationRule< 3 >::Create
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Owen2011MigrationRule< 3 > > ( *Create_function_type )(  );
            
            Owen2011MigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::Owen2011MigrationRule< 3 >::Create ) );
        
        }
        { //::Owen2011MigrationRule< 3 >::GetIndices
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( Owen2011MigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::Owen2011MigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&Owen2011MigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::Owen2011MigrationRule< 3 >::SetCellChemotacticParameter
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellChemotacticParameter_function_type)( double ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "SetCellChemotacticParameter"
                , SetCellChemotacticParameter_function_type( &::Owen2011MigrationRule< 3 >::SetCellChemotacticParameter )
                , ( bp::arg("cellChemotacticParameter") ) );
        
        }
        { //::Owen2011MigrationRule< 3 >::SetCellMotilityParameter
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellMotilityParameter_function_type)( double ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "SetCellMotilityParameter"
                , SetCellMotilityParameter_function_type( &::Owen2011MigrationRule< 3 >::SetCellMotilityParameter )
                , ( bp::arg("cellMotility") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( Owen2011MigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&Owen2011MigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        Owen2011MigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Owen2011MigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011MigrationRule< 3 > >, boost::shared_ptr< LatticeBasedMigrationRule< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011MigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
    }

    { //::Owen2011SproutingRule< 3 >
        typedef bp::class_< Owen2011SproutingRule_less__3__greater__wrapper > Owen2011SproutingRule3_exposer_t;
        Owen2011SproutingRule3_exposer_t Owen2011SproutingRule3_exposer = Owen2011SproutingRule3_exposer_t( "Owen2011SproutingRule3", bp::init< >() );
        bp::scope Owen2011SproutingRule3_scope( Owen2011SproutingRule3_exposer );
        { //::Owen2011SproutingRule< 3 >::Create
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Owen2011SproutingRule< 3 > > ( *Create_function_type )(  );
            
            Owen2011SproutingRule3_exposer.def( 
                "Create"
                , Create_function_type( &::Owen2011SproutingRule< 3 >::Create ) );
        
        }
        { //::Owen2011SproutingRule< 3 >::GetSprouts
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( Owen2011SproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            Owen2011SproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::Owen2011SproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&Owen2011SproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::Owen2011SproutingRule< 3 >::SetHalfMaxVegf
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHalfMaxVegf_function_type)( double ) ;
            
            Owen2011SproutingRule3_exposer.def( 
                "SetHalfMaxVegf"
                , SetHalfMaxVegf_function_type( &::Owen2011SproutingRule< 3 >::SetHalfMaxVegf )
                , ( bp::arg("halfMaxVegf") ) );
        
        }
        Owen2011SproutingRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Owen2011SproutingRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011SproutingRule< 3 > >, boost::shared_ptr< LatticeBasedSproutingRule< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011SproutingRule< 3 > >, boost::shared_ptr< AbstractSproutingRule< 3 > > >();
    }
}
